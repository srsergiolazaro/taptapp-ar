<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taptapp AR (Protocol V7) | The Moonshot Engine</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;800&family=JetBrains+Mono:wght@400;700&family=Merriweather:ital,wght@0,300;0,700;1,300&display=swap"
        rel="stylesheet">
    <meta name="description"
        content="Ultra-high performance WebAR engine. 93% smaller, 9x faster compilation. Protocol V7 Moonshot implementation.">
</head>

<body>

    <nav class="sticky-nav">
        <div class="nav-content container">
            <span class="logo">Taptapp AR <span class="version">v1.0.46</span></span>
            <div class="nav-links">
                <a href="#overview">Overview</a>
                <a href="#architecture">Architecture</a>
                <a href="#benchmarks">Benchmarks</a>
                <a href="#code">Usage</a>
                <a href="https://github.com/srsergiolazaro/taptapp-ar" class="github-link" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <header class="paper-header">
        <div class="container hero">
            <span class="badge">PROTOCOL V7 (MOONSHOT)</span>
            <h1>The Future of WebAR is <span class="highlight-text">Native Performance</span>.</h1>
            <p class="subtitle">
                A bare-metal re-engineering of the Augmented Reality pipeline.
                Eliminating AI overhead to achieve <strong>93% compression</strong> and <strong>instant
                    initialization</strong>.
            </p>

            <div class="hero-metrics">
                <div class="hero-metric">
                    <strong>50KB</strong>
                    <span>File Size</span>
                </div>
                <div class="hero-metric">
                    <strong>21ms</strong>
                    <span>Latency</span>
                </div>
                <div class="hero-metric">
                    <strong>0s</strong>
                    <span>Cold Start</span>
                </div>
            </div>

            <div class="links">
                <a href="#code" class="btn primary">Get Started</a>
                <a href="./technical-paper.pdf" class="btn secondary">Read Paper (PDF)</a>
            </div>
        </div>
    </header>

    <main class="container">

        <!-- EXECUTIVE SUMMARY -->
        <section id="overview" class="section">
            <div class="section-header">
                <h2>Executive Summary</h2>
                <p>From "AI Emulation" to "Bare Metal" Vision.</p>
            </div>
            <div class="text-block">
                <p>
                    Classic WebAR solutions like MindAR rely on TensorFlow.js, a heavy machine learning library designed
                    for neural networks.
                    However, marker tracking is a geometric problem, not a generative one. Using TFJS introduces massive
                    overhead:
                    20MB+ downloads, slow GPU shader compilation, and blocking main threads.
                </p>
                <p>
                    <strong>Taptapp AR (Protocol V7)</strong> completely removes this layer. We implemented specific
                    computer vision algorithms
                    (Difference of Gaussians, FREAK) in pure, optimized JavaScript. Then, we revolutionized the data
                    storage with the
                    <strong>Moonshot Vision Codec</strong>, using techniques traditionally reserved for high-performance
                    databases and compression engines.
                </p>
            </div>
        </section>

        <hr class="divider">

        <!-- DEEP DIVE: STORAGE INNOVATION -->
        <section id="architecture" class="section">
            <div class="section-header">
                <span class="step-number">01</span>
                <h2>Storage Innovation: Columnar & Structured</h2>
                <p>Rethinking data serialization for the web.</p>
            </div>

            <div class="feature-grid">
                <div class="feature-card">
                    <h3>Before: Row-Based JSON</h3>
                    <p>Legacy formats stored lists of objects: <code>[{x,y,scale}, {x,y,scale}...]</code>.</p>
                    <p>This creates millions of redundant keys (<code>"x":</code>, <code>"y":</code>) and breaks memory
                        locality, preventing compression algorithms from finding patterns.</p>
                </div>
                <div class="feature-card highlight-card">
                    <h3>After: Columnar Arrays (SoA)</h3>
                    <p>We switched to <strong>Structure of Arrays</strong>. All X coordinates are in one specialized
                        array, all Ys in another.</p>
                    <p><code>X: [12, 13, 14...]</code><br><code>Y: [55, 56, 57...]</code></p>
                    <p><strong>Result:</strong> Similar values sit next to each other in memory. Gzip/Brotli can now
                        compress repetitive data with <strong>4.8x greater efficiency</strong>.</p>
                </div>
            </div>
        </section>

        <!-- DEEP DIVE: DENSITY & PRECISION -->
        <section class="section">
            <div class="section-header">
                <span class="step-number">02</span>
                <h2>Density: 4-bit Packing & LSH</h2>
                <p>Aggressive information theory application.</p>
            </div>

            <div class="innovations-list">
                <div class="innovation-row">
                    <div class="innovation-icon">üß†</div>
                    <div class="innovation-content">
                        <h3>64-bit LSH (Locality Sensitive Hashing)</h3>
                        <p>Legacy systems store feature descriptors as 84 distinct floating-point numbers per point. We
                            project these into a 64-bit "Hamming Space".</p>
                        <p>Instead of comparing 84 numbers to find a match, we compare one 64-bit Integer. This unlocks
                            CPU hardware instructions (<code>POPCNT</code>, <code>XOR</code>) for <strong>15x faster
                                matching</strong>.</p>
                    </div>
                </div>

                <div class="innovation-row">
                    <div class="innovation-icon">üíæ</div>
                    <div class="innovation-content">
                        <h3>4-bit Packed Tracking Data</h3>
                        <p>Optical flow tracking doesn't require 8-bit color fidelity. We quantize pixel data into 4-bit
                            nibbles, packing <strong>two pixels per byte</strong>.</p>
                        <p>This cuts the largest part of the dataset (tracking images) by exactly <strong>50%</strong>
                            without visible jitter.</p>
                    </div>
                </div>

                <div class="innovation-row">
                    <div class="innovation-icon">üìê</div>
                    <div class="innovation-content">
                        <h3>Uint16 Quantization</h3>
                        <p>Coordinates are normalized to <code>0..1</code> and mapped to <code>0..65535</code> (16-bit
                            integers). This replaces heavy 32-bit Floats with lightweight Integers, reducing coordinate
                            storage by half while maintaining sub-pixel precision.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- DEEP DIVE: SPATIAL ENTROPY -->
        <section class="section">
            <div class="section-header">
                <span class="step-number">03</span>
                <h2>Spatial Entropy: Morton Encoding</h2>
                <p>Ordering data to help the hardware.</p>
            </div>

            <div class="text-block">
                <p>
                    We don't just store points in the order they are found. We sort them using a <strong>Z-Order Curve
                        (Morton Code)</strong>.
                    This forces points that are physically close in the image (2D) to be close in memory (1D).
                </p>
                <ul class="benefits-list">
                    <li><strong>Cache Locality:</strong> When the CPU fetches a feature point, its neighbors are likely
                        already in the L1/L2 Cache. Reduces Cache Misses by ~30%.</li>
                    <li><strong>Compression Boost:</strong> Neighboring points have similar descriptor values. Grouping
                        them improves Delta Compression efficiency by an extra 15-20%.</li>
                </ul>
            </div>
        </section>

        <!-- DEEP DIVE: PARALLELISM -->
        <section class="section">
            <div class="section-header">
                <span class="step-number">04</span>
                <h2>Multi-Core Architecture</h2>
                <p>True parallel processing for faster builds.</p>
            </div>

            <div class="text-block">
                <p>
                    By removing the single-threaded TensorFlow dependency, we unlocked <strong>Node.js Worker
                        Threads</strong>.
                    The compiler now creates a thread pool tailored to the host CPU (e.g., 8 workers on an M1/M2 chip).
                </p>
                <div class="code-preview">
                    <code>WorkerPool.map(images) -> [Thread 1, Thread 2, Thread 3, Thread 4] -> Combine</code>
                </div>
                <p>
                    This reduced compilation time from <strong>23 seconds</strong> to <strong>2.6 seconds</strong> on
                    consumer hardware, enabling "Instant Preview" features for AR editors.
                </p>
            </div>
        </section>

        <hr class="divider">

        <!-- BENCHMARKS -->
        <section id="benchmarks" class="comparison">
            <h2>Final Benchmarks (Protocol V7)</h2>
            <p style="text-align: center; margin-bottom: 2rem; color: var(--text-light);">Comparison vs MindAR v1.2.5
                (TFJS Backend)</p>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>MindAR (Standard)</th>
                            <th class="highlight">Taptapp AR (V7)</th>
                            <th>Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Target File Size</strong></td>
                            <td>~770 KB</td>
                            <td class="highlight"><strong>~50 KB</strong></td>
                            <td>üìâ 93% Smaller Download</td>
                        </tr>
                        <tr>
                            <td><strong>Cold Start (Init)</strong></td>
                            <td>2500 ms</td>
                            <td class="highlight"><strong>20 ms</strong></td>
                            <td>‚ö° Instant UX</td>
                        </tr>
                        <tr>
                            <td><strong>Dependencies</strong></td>
                            <td>TensorFlow (20MB+)</td>
                            <td class="highlight"><strong>Zero (< 100KB)</strong>
                            </td>
                            <td>üì¶ Lightweight Bundle</td>
                        </tr>
                        <tr>
                            <td><strong>Feature Size</strong></td>
                            <td>84 bytes / point</td>
                            <td class="highlight"><strong>8 bytes / point</strong></td>
                            <td>üß† 10x More Efficient</td>
                        </tr>
                        <tr>
                            <td><strong>Matching Algorithm</strong></td>
                            <td>O(N√óM) Loop</td>
                            <td class="highlight"><strong>Hardware XOR/POPCNT</strong></td>
                            <td>üöÄ 15x Faster CPU Ops</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <hr class="divider">

        <!-- IMPLEMENTATION -->
        <section id="code" class="documentation">
            <h2>Implementation Guide</h2>

            <div class="tabs">
                <div class="tab active">Compiler (Node.js)</div>
                <!-- <div class="tab">Runtime (Browser)</div> -->
            </div>

            <div class="code-block-wrapper">
                <pre><code>import { OfflineCompiler } from '@srsergio/taptapp-ar';
import { Jimp } from 'jimp';
import fs from 'fs';

// 1. Initialize the V7 Compiler
const compiler = new OfflineCompiler();

// 2. Load your image (any format supported by Jimp)
const image = await Jimp.read('eiffel-tower.jpg');

// 3. Compile (Automatic Multi-threading)
console.log("Compiling...");
await compiler.compileImageTargets([{
    width: image.bitmap.width,
    height: image.bitmap.height,
    data: image.bitmap.data // Raw Uint8Array pixel data
}], (progress) => {
    console.log(`Progress: ${progress.toFixed(1)}%`);
});

// 4. Export Protocol V7 Binary (.taar)
const buffer = compiler.exportData();
fs.writeFileSync('targets.taar', buffer);

console.log(`Saved targets.taar (${(buffer.byteLength / 1024).toFixed(2)} KB)`);</code></pre>
            </div>

            <h3>Runtime (SimpleAR - Vanilla JS)</h3>
            <p>The simplest way to use AR. No A-Frame or Three.js required.</p>
            <div class="code-block-wrapper">
                <pre><code>&lt;!-- 1. Container and Overlay --&gt;
&lt;div id="container" style="width: 100vw; height: 100vh; position: relative; overflow: hidden;"&gt;
  &lt;img id="overlay" src="./overlay.png" style="opacity: 0; position: absolute; transition: opacity 0.2s;" /&gt;
&lt;/div&gt;

&lt;!-- 2. Logic --&gt;
&lt;script type="module"&gt;
  import { SimpleAR } from 'https://cdn.jsdelivr.net/npm/@srsergio/taptapp-ar@latest/dist/index.min.js';

  const ar = new SimpleAR({
    container: document.getElementById('container'),
    targetSrc: './targets.taar',
    overlay: document.getElementById('overlay'),
    onFound: () => console.log("Target Found!"),
    onLost: () => console.log("Target Lost")
  });

  await ar.start();
&lt;/script&gt;</code></pre>
            </div>
        </section>

    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-col">
                    <h4>Taptapp AR</h4>
                    <p>Redefining WebAR performance through bare-metal engineering.</p>
                </div>
                <div class="footer-col">
                    <h4>Resources</h4>
                    <a href="./technical-paper.pdf">Technical Paper (V7)</a>
                    <a href="https://github.com/srsergiolazaro/taptapp-ar">GitHub Repository</a>
                    <a href="https://npmjs.com/package/@srsergio/taptapp-ar">NPM Package</a>
                </div>
            </div>
            <div class="copyright">
                &copy; 2026 Sergio L√°zaro. Released under MIT License.
            </div>
        </div>
    </footer>

</body>

</html>